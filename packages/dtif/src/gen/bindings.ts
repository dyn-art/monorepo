// This file has been generated by Specta. DO NOT EDIT.

/**
 * Represents the absolute position and orientation of a node within the composition's coordinate system.
 * This mixin stores the transformation as a 3x3 matrix (Mat3),
 * which includes translation, rotation, and skew.
 * 
 * Note: This transformation does not include scaling.
 * For scaling, refer to the `DimensionMixin`.
 */
export type AbsoluteTransformMixin = Mat3

/**
 * Represents an anchor point in a path, defining a specific location and command.
 */
export type Anchor = { 
/**
 * The position of the anchor point in 2D space.
 */
position: Vec2; 
/**
 * The command associated with the anchor point,
 * defining how the path should proceed from this point.
 */
command: AnchorCommand }

export type AnchorCommand = 
/**
 * Moves the path to a new location without drawing anything.
 */
"MoveTo" | 
/**
 * Draws a straight line from the current position to the anchor point.
 */
"LineTo" | 
/**
 * Draws a curve to the anchor point using two control points.
 */
{ CurveTo: { 
/**
 * The first control point for the curve.
 */
controlPoint1: Vec2; 
/**
 * The second control point for the curve.
 */
controlPoint2: Vec2 } } | 
/**
 * Draws an arc to the anchor point.
 */
{ ArcTo: { 
/**
 * The radius of the arc in 2D space.
 */
radius: Vec2; 
/**
 * The rotation of the arc's x-axis, in degrees.
 */
xAxisRotation: number; 
/**
 * A flag to determine if the arc should be the larger of the two possible arcs.
 */
largeArcFlag: boolean; 
/**
 * A flag to determine the direction of the arc sweep.
 */
sweepFlag: boolean } } | 
/**
 * Closes the path by drawing a line to the start point.
 */
"ClosePath"

export type AnyCoreInputEvent = { events: CoreInputEvent[] }

export type AnyInputEvent = ({ type: "Core" } & AnyCoreInputEvent) | ({ type: "Interaction" } & AnyInteractionInputEvent)

export type AnyInteractionInputEvent = { events: InteractionInputEvent[] }

/**
 * Emitted when an attribute of a SVGElement is removed.
 */
export type AttributeRemoved = { key: string }

/**
 * Emitted when an attribute of an SVGElement is updated.
 */
export type AttributeUpdated = { newValue: SVGAttribute }

/**
 * Defines blending properties for a node.
 */
export type BlendMixin = { 
/**
 * Specifies the blend mode for the node.
 * Blend mode determines how the node's color blends with colors beneath it.
 */
blendMode: BlendMode; 
/**
 * The opacity of the node,
 * ranging from 0.0 (completely transparent) to 1.0 (completely opaque).
 */
opacity: number; 
/**
 * Indicates whether the node is used as a mask.
 */
isMask: boolean }

export type BlendMode = "Normal" | "Multiply" | "Screen" | "Overlay" | "Darken" | "Lighten" | "ColorDodge" | "ColorBurn" | "HardLight" | "SoftLight" | "Difference" | "Exclusion" | "Hue" | "Saturation" | "Color" | "Luminosity"

/**
 * Defines how text should break lines within its container.
 */
export type BreakLineOn = 
/**
 * Breaks lines at word boundaries using the Unicode Line Breaking Algorithm.
 */
"WordBoundary" | 
/**
 * Breaks lines at any character, possibly splitting words.
 */
"AnyCharacter" | 
/**
 * Disables automatic line breaking. Respects explicit line breaks like '\n'.
 */
"NoWrap"

/**
 * Manages the child entities of a node in a hierarchical structure.
 * 
 * The children are sorted back-to-front,
 * meaning the first child in the vector is the bottommost layer in the scene,
 * and the last child is the topmost layer.
 */
export type ChildrenMixin = Entity[]

export type CoreInputEvent = ({ type: "EntityMoved" } & EntityMoved) | ({ type: "EntitySetPosition" } & EntitySetPosition)

export type CursorChangeEvent = { cursor: CursorForFrontend }

export type CursorDownOnComposition = { position: Vec2 }

export type CursorDownOnEntity = { entity: Entity; position: Vec2 }

export type CursorDownOnResizeHandle = { initialBounds: XYWH; corner: number; rotationInRadians: number }

export type CursorDownOnRotateHandle = { corner: number; initialRotationInRadians: number }

export type CursorEnteredComposition = null

export type CursorExitedComposition = null

export type CursorForFrontend = { type: "Default" } | { type: "Resize"; rotationInDegrees: number } | { type: "Rotate"; rotationInDegrees: number }

export type CursorMovedOnComposition = { position: Vec2 }

export type CursorUpOnComposition = { position: Vec2 }

/**
 * Represents the composition in which all nodes exist.
 */
export type DTIFComposition = { 
/**
 * The version of the composition type declaration, used internally.
 * Defaults to the latest version.
 */
version?: string; 
/**
 * The name of the composition.
 * Example: 'My super cool composition'.
 */
name: string; 
/**
 * The width of the composition, in units.
 */
width: number; 
/**
 * The height of the composition, in units.
 */
height: number; 
/**
 * The identifier of the root node in the composition.
 */
rootNodeId: Entity; 
/**
 * A mapping of node identifiers to their corresponding nodes within the composition.
 * Note: Planned to directly use `Entity` as a key once the referenced serde issue is resolved.
 * https://github.com/serde-rs/serde/issues/1183
 */
nodes: { [key in string]: DTIFNode }; 
/**
 * A mapping of paint identifiers to their corresponding paints within the composition.
 * Note: Planned to directly use `Entity` as a key once the referenced serde issue is resolved.
 * https://github.com/serde-rs/serde/issues/1183
 */
paints: { [key in string]: Paint }; 
/**
 * A mapping of font identifiers to their corresponding font data within the composition.
 * Note: Planned to directly use `u64` as a key once the referenced serde issue is resolved.
 * https://github.com/serde-rs/serde/issues/1183
 */
fonts?: { [key in string]: FontWithContent } | null; 
/**
 * Optional list of changes represented as core input events.
 * This field is optional and defaults to `None` if not provided.
 */
changes?: CoreInputEvent[] | null }

export type DTIFNode = ({ type: "Frame" } & FrameNodeBundle) | ({ type: "Group" } & GroupNodeBundle) | ({ type: "Rectangle" } & RectangleNodeBundle) | ({ type: "Text" } & TextNodeBundle)

/**
 * Represents the dimensional properties of a node, specifically its width and height.
 */
export type DimensionMixin = { 
/**
 * The width of the node, measured in units (likely pixels).
 * This field specifies the horizontal dimension of the node.
 */
width: number; 
/**
 * The height of the node, measured in units (likely pixels).
 * This field determines the vertical dimension of the node.
 */
height: number }

/**
 * Emitted when a SVGElement (child) is append to another SVGElement (parent).
 */
export type ElementAppended = { parentId: number }

/**
 * Emitted when a new SVGElement is created.
 */
export type ElementCreated = { tagName: string; attributes: SVGAttribute[]; styles: SVGStyle[]; parentId: number | null; isBundleRoot: boolean; entity: Entity | null }

/**
 * Emitted when a SVGElement is deleted.
 */
export type ElementDeleted = Record<string, never>

/**
 * Represents a basic shape node for an ellipse.
 * Note that a circle is a special case of an ellipse where the width equals the height.
 */
export type Ellipse = { 
/**
 * Contains the arc data for the ellipse,
 * which includes the starting angle, ending angle, and the inner radius ratio.
 * These properties are used to create arcs and donuts shapes.
 */
arcData: EllipseArcData }

/**
 * Represents the arc data for an ellipse.
 * This includes properties for defining the sweep of the ellipse and its inner radius,
 * which are used in UI elements to create various elliptical shapes.
 */
export type EllipseArcData = { 
/**
 * The starting angle of the ellipse's arc.
 */
startingAngle: number; 
/**
 * The ending angle of the ellipse's arc.
 */
endingAngle: number; 
/**
 * The ratio of the inner radius to the outer radius of the ellipse.
 * A value of 0 indicates a full ellipse, while higher values create a 'donut' shape.
 */
innerRadiusRatio: number }

export type Entity = number

export type EntityMoved = { entity: Entity; dx: number; dy: number }

export type EntitySetPosition = { entity: Entity; x: number; y: number }

/**
 * Manages the fill properties of a graphical object.
 */
export type FillMixin = { 
/**
 * A collection of `Paint` objects,
 * each defining a different aspect of how the object is filled.
 */
paintIds: Entity[] }

/**
 * Represents a font with specific characteristics.
 * Used for text rendering and styling.
 */
export type FontMetadata = { 
/**
 * The name of the font, often used for display purposes.
 */
name: string; 
/**
 * The font family to which this font belongs.
 */
family: string; 
/**
 * The style of the font, such as italic or normal.
 */
style: FontStyle; 
/**
 * The weight of the font, typically ranging from 100 (thin) to 900 (black).
 */
weight: number }

/**
 * Defines the style of a font, such as italic or normal.
 */
export type FontStyle = 
/**
 * The standard, upright style of the font.
 */
"Normal" | 
/**
 * A style where the letters slant to the right.
 */
"Italic"

/**
 * Extends the `Font` structure with additional content for rendering.
 * Includes a preview URL and the font content itself.
 */
export type FontWithContent = { 
/**
 * The base font information.
 */
metadata: FontMetadata; 
/**
 * The actual content of the font as binary data.
 */
content: number[] }

/**
 * Acts as a container used to define a layout hierarchy.
 * It functions similarly to an HTML `<div>` element.
 * This is distinct from a `GroupNode`, which is more akin to a folder for layers in its use and functionality.
 */
export type Frame = { 
/**
 * Indicates whether the frame clips its content to its bounding box.
 * When set to `true`, content that extends beyond the frame's boundaries will be clipped.
 * When `false`, content can extend beyond the frame's boundaries without being clipped.
 */
clipContent: boolean }

export type FrameNodeBundle = { node?: Node; frame?: Frame; rectangleCornerMixin?: RectangleCornerMixin; children: ChildrenMixin; compositionMixin?: NodeCompositionMixin; relativeTransform: RelativeTransformMixin; dimension: DimensionMixin; blendMixin?: BlendMixin; fill?: FillMixin }

/**
 * Serves as a container used to semantically group related nodes,
 * analogous to a folder in a layers panel.
 * This is in contrast to the `Frame` node, which is used to define layout and is
 * more akin to an HTML `<div>` element.
 * 
 * Groups are automatically positioned and sized to accommodate their content.
 * As a result, while it is possible to move or resize a `Group`, be aware that its
 * position and size are subject to change in response to modifications of its content.
 */
export type Group = null

export type GroupNodeBundle = { node?: Node; group?: Group; children: ChildrenMixin; compositionMixin?: NodeCompositionMixin; relativeTransform: RelativeTransformMixin; dimension: DimensionMixin; blendMixin?: BlendMixin }

export type HandleSide = "Top" | "Bottom" | "Left" | "Right"

/**
 * Horizontal alignment options for text within its container.
 */
export type HorizontalTextAlignment = 
/**
 * Aligns text to the left side of its container.
 */
"Left" | 
/**
 * Centers text horizontally within its container.
 */
"Center" | 
/**
 * Aligns text to the right side of its container.
 */
"Right" | 
/**
 * Justifies text across the container width.
 */
"Justified"

export type InteractionInputEvent = ({ type: "CursorDownOnEntity" } & CursorDownOnEntity) | ({ type: "CursorMovedOnComposition" } & CursorMovedOnComposition) | ({ type: "CursorEnteredComposition" }) | ({ type: "CursorExitedComposition" }) | ({ type: "CursorDownOnComposition" } & CursorDownOnComposition) | ({ type: "CursorUpOnComposition" } & CursorUpOnComposition) | ({ type: "CursorDownOnResizeHandle" } & CursorDownOnResizeHandle) | ({ type: "CursorDownOnRotateHandle" } & CursorDownOnRotateHandle)

export type InteractionModeChangeEvent = { interactionMode: InteractionModeForFrontend }

export type InteractionModeForFrontend = { type: "None" } | { type: "Pressing" } | { type: "Translating" } | { type: "Resizing" } | { type: "Rotating" }

/**
 * Options for spacing between characters in a text segment.
 */
export type LetterSpacing = 
/**
 * Automatic spacing based on font metrics.
 */
"Auto" | 
/**
 * Fixed spacing in pixels.
 */
{ Pixels: number } | 
/**
 * Spacing as a percentage of font size.
 */
{ Percent: number }

/**
 * Options for controlling line height in text.
 */
export type LineHeight = 
/**
 * Automatic line height based on font metrics.
 */
"Auto" | 
/**
 * Fixed line height in pixels.
 */
{ Pixels: number } | 
/**
 * Line height as a percentage of font size.
 */
{ Percent: number }

export type Locked = null

export type Mat3 = [number, number, number, number, number, number, number, number, number]

export type MixinChange = ({ type: "RectangleCorner" } & RectangleCornerMixin) | ({ type: "Children" } & MixinChangeChildrenMixin) | ({ type: "Dimension" } & DimensionMixin) | ({ type: "RelativeTransform" } & MixinChangeRelativeTransformMixin) | ({ type: "Composition" } & NodeCompositionMixin) | ({ type: "Blend" } & BlendMixin) | ({ type: "Path" } & PathMixin) | ({ type: "Fill" } & FillMixin)

/**
 * Represents the change in the ChildrenMixin.
 * 
 * This struct separates `ChildrenMixin` due to a type conflict between Rust and TypeScript.
 * In Rust, `ChildrenMixin` is a `Vec<Entity>`, but in TypeScript, it's represented as `Entity[]`.
 * The TypeScript representation can't merge with an object type like
 * `({type: 'Children'} & Entity[])` without conflict.
 */
export type MixinChangeChildrenMixin = { children: ChildrenMixin }

export type MixinChangeRelativeTransformMixin = { relativeTransform: RelativeTransformMixin }

/**
 * Represents a basic node in the composition.
 */
export type Node = { 
/**
 * Represents the specific type of the node, such as `Rectangle`, `Ellipse`, `Star`, etc.
 * This field is redundant but neccessary to distinguish different nodes in the rendering process,
 * without a big overhead like a separate system for each node type/variant.
 */
node_type: NodeType; 
/**
 * The name of the node.
 * This is an optional field and can be used to label the node with a descriptive name,
 * such as 'Cool Node'.
 * If not provided, it defaults to `None`.
 */
name: string | null }

/**
 * Contains properties related to the composition settings of a node.
 */
export type NodeCompositionMixin = { 
/**
 * Determines the visibility of the node.
 */
isVisible: boolean; 
/**
 * Indicates whether the node is locked or not.
 * A locked node restricts certain user interactions,
 * such as selecting or dragging on the canvas.
 */
isLocked: boolean }

export type NodeType = "None" | "Group" | "Rectangle" | "Frame" | "Text"

export type OutputEvent = ({ type: "RenderUpdate" } & RenderUpdateEvent) | ({ type: "TrackUpdate" } & TrackUpdateEvent) | ({ type: "SelectionChange" } & SelectionChangeEvent) | ({ type: "InteractionModeChange" } & InteractionModeChangeEvent) | ({ type: "CursorChange" } & CursorChangeEvent)

export type Paint = 
/**
 * Represents a solid color paint.
 */
({ type: "Solid" } & SolidPaint)

/**
 * Represents a path in a graphical composition, defined by a series of vertices.
 * Each vertex is an anchor point, and the path is constructed by connecting these points.
 */
export type PathMixin = { 
/**
 * A collection of `Anchor` points that define the shape of the path.
 * These vertices determine the path's outline through various commands.
 */
vertices: Anchor[] }

/**
 * Represents a basic shape node for a regular convex polygon with three or more sides.
 */
export type Polygon = { 
/**
 * The number of sides of the polygon.
 * This value must be an integer greater than or equal to 3.
 */
pointCount: number }

/**
 * Represents a basic shape node for a rectangle.
 * It is a fundamental building block used to create and manipulate rectangular shapes
 * within the composition.
 */
export type Rectangle = null

/**
 * Provides corner radius properties for rectangle like nodes.
 */
export type RectangleCornerMixin = { 
/**
 * The radius in pixels for rounding the top left corner of the node.
 * This value determines how curved the top left corner will be.
 */
topLeftRadius: number; 
/**
 * The radius in pixels for rounding the top right corner of the node.
 * This value influences the curvature of the top right corner.
 */
topRightRadius: number; 
/**
 * The radius in pixels for rounding the bottom right corner of the node.
 * Adjusts the curve of the bottom right corner.
 */
bottomRightRadius: number; 
/**
 * The radius in pixels for rounding the bottom left corner of the node.
 * Modifies the roundness of the bottom left corner.
 */
bottomLeftRadius: number }

export type RectangleNodeBundle = { node?: Node; recangle?: Rectangle; rectangleCornerMixin?: RectangleCornerMixin; compositionMixin?: NodeCompositionMixin; relativeTransform: RelativeTransformMixin; dimension: DimensionMixin; blendMixin?: BlendMixin; fill?: FillMixin }

/**
 * Represents the relative position and orientation of a node within its parent's coordinate system.
 * This mixin stores the transformation as a 3x3 matrix (Mat3),
 * which includes translation, rotation, and skew.
 * 
 * Note: This transformation does not include scaling.
 * For scaling, refer to the `DimensionMixin`.
 */
export type RelativeTransformMixin = Mat3

/**
 * Represents the different types of events that can be emitted by a SVGElement
 * to synchronize its state with the frontend.
 * 
 * Note on Child Element Management:
 * - Child elements are managed implicitly through their own lifecycle events rather than
 * explicit child addition or removal events.
 * - When a child element is created (`ElementCreated`), it includes an optional `parent_id`
 * indicating its parent. This way, the frontend knows to append this new child element
 * to the specified parent element.
 * - When a child element is deleted (`ElementDeleted`), it is responsible for removing itself
 * from the DOM. The parent element implicitly recognizes this removal.
 * - This approach avoids the need for separate `ChildAdded` or `ChildRemoved` events, simplifying
 * the event model and reducing the number of events needed to manage the DOM structure.
 */
export type RenderChange = ({ type: "ElementCreated" } & ElementCreated) | ({ type: "ElementDeleted" }) | ({ type: "ElementAppended" } & ElementAppended) | ({ type: "AttributeUpdated" } & AttributeUpdated) | ({ type: "AttributeRemoved" } & AttributeRemoved) | ({ type: "StyleUpdated" } & StyleUpdated) | ({ type: "StyleRemoved" } & StyleRemoved)

export type RenderUpdateEvent = { id: number; updates: RenderChange[] }

/**
 * Marks the root node within the composition or scene.
 * 
 * This component is intended to be used with only one entity in the world
 * to represent the starting point of the composition.
 * It is important to note that there is no automatic enforcement
 * at the Bevy framework level to ensure the uniqueness of this component.
 * As such, maintaining the singularity of this component must be managed
 * through game logic or specific programming measures to prevent multiple instances.
 */
export type Root = null

export type SVGAttribute = { type: "Id"; id: number } | { type: "Width"; width: number; unit: SVGMeasurementUnit } | { type: "Height"; height: number; unit: SVGMeasurementUnit } | { type: "Opacity"; opacity: number } | { type: "Transform"; transform: SVGTransformAttribute } | { type: "D"; d: SVGPathCommand[] } | { type: "ClipPath"; clipPath: number } | { type: "Fill"; fill: string } | { type: "Name"; name: string }

export type SVGBlendMode = { type: "Normal" } | { type: "Multiply" } | { type: "Screen" } | { type: "Overlay" } | { type: "Darken" } | { type: "Lighten" } | { type: "ColorDodge" } | { type: "ColorBurn" } | { type: "HardLight" } | { type: "SoftLight" } | { type: "Difference" } | { type: "Exclusion" } | { type: "Hue" } | { type: "Saturation" } | { type: "Color" } | { type: "Luminosity" }

export type SVGDisplayStyle = { type: "Block" } | { type: "None" }

export type SVGMeasurementUnit = { type: "Pixel" } | { type: "Percent" }

export type SVGPathCommand = { type: "MoveTo"; x: number; y: number } | { type: "LineTo"; x: number; y: number } | { type: "CurveTo"; cx1: number; cy1: number; cx2: number; cy2: number; x: number; y: number } | { type: "ArcTo"; rx: number; ry: number; xAxisRotation: number; largeArcFlag: boolean; sweepFlag: boolean; x: number; y: number } | { type: "ClosePath" }

export type SVGStyle = { type: "Display"; display: SVGDisplayStyle } | { type: "BlendMode"; blendMode: SVGBlendMode }

export type SVGTransformAttribute = { type: "Matrix"; a: number; b: number; c: number; d: number; tx: number; ty: number }

export type Selected = null

export type SelectionChangeEvent = { selected: Entity[] }

export type SolidPaint = { 
/**
 * The color of the paint, represented as an RGB array
 * where each component ranges from 0 to 255.
 */
color: [number, number, number]; 
/**
 * The opacity of the paint,
 * ranging from 0.0 (completely transparent) to 1.0 (completely opaque).
 */
opacity: number; 
/**
 * The blend mode used when applying the paint,
 * which determines how the paint's color blends with colors underneath it.
 */
blendMode: BlendMode; 
/**
 * Determines whether the paint is visible.
 */
isVisible: boolean }

/**
 * Represents a basic shape node for a star with a set number of points.
 */
export type Star = { 
/**
 * The number of "spikes", or outer points of the star.
 * This value must be an integer greater than or equal to 3.
 */
pointCount: number; 
/**
 * The ratio of the inner radius to the outer radius of the star.
 * This value is used to define the sharpness of the star's points.
 */
innerRadiusRatio: number }

/**
 * Emitted when a style property of a SVGElement is removed.
 */
export type StyleRemoved = { key: string }

/**
 * Emitted when a style property of a SVGElement is updated.
 */
export type StyleUpdated = { newValue: SVGStyle }

/**
 * Represents a text node with customizable style and layout properties.
 */
export type Text = { 
/**
 * Sections of the text, each with its own style.
 */
segments: TextSegment[]; 
/**
 * Horizontal alignment of the text within its container.
 */
horizontalTextAlignment?: HorizontalTextAlignment; 
/**
 * Vertical alignment of the text within its container.
 */
verticalTextAlignment?: VerticalTextAlignment; 
/**
 * Behavior of text line breaking at the bounds of its container.
 */
linebreakBehaviour?: BreakLineOn }

export type TextNodeBundle = { node?: Node; text: Text; compositionMixin?: NodeCompositionMixin; relativeTransform: RelativeTransformMixin; dimension: DimensionMixin; blendMixin?: BlendMixin; fill?: FillMixin }

/**
 * A segment of text with a specific style.
 */
export type TextSegment = { 
/**
 * Text content of the segment.
 */
value: string; 
/**
 * Style properties applied to this segment.
 */
style: TextStyle }

/**
 * Style properties for a text segment, defining its appearance.
 */
export type TextStyle = { 
/**
 * Height of rasterized glyphs in pixels, influenced by window scale.
 */
fontSize: number; 
/**
 * Primary font identifier.
 */
fontId: number; 
/**
 * Spacing between characters.
 */
letterSpacing?: LetterSpacing; 
/**
 * Vertical spacing between lines of text.
 */
lineHeight?: LineHeight }

export type TrackUpdateEvent = { id: Entity; updates: MixinChange[] }

export type TrackableMixinType = { type: "Dimension" } | { type: "RelativeTransform" }

export type Vec2 = [number, number]

/**
 * Vertical alignment options for text within its container.
 */
export type VerticalTextAlignment = 
/**
 * Aligns text to the top of its container.
 */
"Top" | 
/**
 * Centers text vertically within its container.
 */
"Center" | 
/**
 * Aligns text to the bottom of its container.
 */
"Bottom"

export type XYWH = { position: Vec2; width: number; height: number }

